//------------------------------
// Module name: or1200_enc_pad_shift
// Function: shift the encryption pad generated by the encryption engines
// by feeding it with a seed value. The shift is controlled by:
// - explicitly by a shift instruction which states the shift initially 
//   and the direction of the shift
// - implicitly by the secure load/store instruction
// p.s. shifting instruction has to be executed initially before implicit
// shift occurs
// Creator:  Bony Chen
// Version:  1.0
// Date:     21 Jan 2015
//------------------------------

`include "or1200_defines.v"

module or1200_enc_pad_shift(
			    clk, rst,
			    // shift value and control inputs
			    shift_ra, shift_rb, shift_imm, shift_read,
			    // enc_fsm_top input
			    enc_pad_in,
			    // or_1200 lsu inputs/outputs
			    to_shift, enc_pad_out,
			    // data cache control inputs and new insn signal
			    ack_i, unstall,
			    // or1200 pipeline stall control signal
			    shift_done, enc_done,
			    // signals used for ofb encryption
			    shifted_value, seed_init
			    );

   input clk;
   input rst;

   input [4:0] shift_ra;
   input [4:0] shift_rb;
   input [10:0] shift_imm;
   input 	shift_read;

   input [127:0] enc_pad_in;
   
   input [`shift_op_size-1:0] to_shift;
   output [31:0] 	      enc_pad_out;

   input 		      ack_i;
   input 		      unstall;

   output 		      shift_done;
   input 		      enc_done;	
   output [7:0] 	      shifted_value;
   input 		      seed_init;

   // internal register
   reg 			      shift_direction;
   reg [7:0] 		      shifted_value;
   reg [127:0] 		      enc_pad_buf;

   reg 			      shift_done;

   reg [10:0] 		      shift_imm_buf;			      
   
 //  parameter IDLE = 2'b00;
 //  parameter WAIT_FOR_ENCDONE = 2'b01;
 //  parameter WAIT_FOR_SEEDINIT = 2'b10;

 //  reg [1:0] 		      state;

   assign enc_pad_out = enc_done ? enc_pad_in[127:96] :
			shift_direction ? enc_pad_buf[127:96] : enc_pad_buf[31:0];
   
  // assign enc_pad_out = shift_direction ? enc_pad_buf[127:96] : enc_pad_buf[31:0];

  reg enc_done_buf;
	
	always @(posedge clk)
		enc_done_buf <= enc_done;
   
   always @(posedge clk or `OR1200_RST_EVENT rst)
     if (rst == `OR1200_RST_VALUE) begin
	shift_direction <= 1;
	enc_pad_buf <= 0;
	shifted_value <= 0;
	shift_imm_buf <= 0;
     end		     
     else begin	
		
	if (seed_init | enc_done_buf) begin
	   enc_pad_buf <= enc_pad_in;
	   if (ack_i) begin
	      shifted_value <= shifted_value + to_shift;
	      enc_pad_buf <=  shift_direction ? 
	     		      enc_pad_in << to_shift : 
	     		      enc_pad_in >> to_shift;
	   end
		
		if (enc_done_buf) shifted_value <= to_shift;
		
		else begin
			 shift_direction <= 1'b1;
			shifted_value <= 8'h0;
		end
	end
	else begin
/*		
		if (shift_read & !unstall)
		  shift_imm_buf <= shift_imm;

		if (shift_read & unstall) begin
		   shift_done <= 1;	     
		   shift_direction <= shift_imm[0];
		   shifted_value <= shift_imm[5:1];
		   enc_pad_buf <= shift_direction ?
				  enc_pad_in << shift_imm[5:1] :
				  enc_pad_in >> shift_imm[5:1];
		end
*/		
		if (ack_i & (shifted_value == 8'h80)) begin
			shifted_value <= to_shift;
			enc_pad_buf <=  shift_direction ? 
	     		      enc_pad_buf << to_shift : 
	     		      enc_pad_buf >> to_shift;
	      shift_done <= 1'b1;
		end else if (ack_i) begin
	      shifted_value <= shifted_value + to_shift;
	      enc_pad_buf <=  shift_direction ? 
	     		      enc_pad_buf << to_shift : 
	     		      enc_pad_buf >> to_shift;
	      shift_done <= 1'b1;
	   end
	end
	
     end // else: !if(rst == `OR1200_RST_VALUE)
   
endmodule	  
