//------------------------------
// Module name: or1200_enc_pad_shift
// Function: shift the encryption pad generated by the encryption engines
// by feeding it with a seed value. The shift is controlled by:
// - explicitly by a shift instruction which states the shift initially 
//   and the direction of the shift
// - implicitly by the secure load/store instruction
// p.s. shifting instruction has to be executed initially before implicit
// shift occurs
// Creator:  Bony Chen
// Version:  1.0
// Date:     21 Jan 2015
//------------------------------

`include "or1200_defines.v"

module or1200_enc_pad_shift(
			    clk, rst,
			    // shift value and control inputs
			    shift_ra, shift_rb, shift_imm, shift_read,
			    // enc_fsm_top input
			    enc_pad_in,
			    // or_1200 lsu inputs/outputs
			    to_shift, enc_pad_out,
			    // data cache control inputs and new insn signal
			    ack_i, unstall,
			    // or1200 pipeline stall control signal
			    shift_done, enc_done
			    );

   input clk;
   input rst;

   input [4:0] shift_ra;
   input [4:0] shift_rb;
   input [10:0] shift_imm;
   input 	shift_read;

   input [127:0] enc_pad_in;
   
   input [`shift_op_size-1:0] to_shift;
   output [31:0] 	      enc_pad_out;

   input 		      ack_i;
   input 		      unstall;

   output 		      shift_done;
   input 		      enc_done;		      

   // internal register
   reg 			      shift_direction;
   reg [7:0] 		      shifted_value;
   reg [127:0] 		      enc_pad_buf;

   reg 			      seed_init;
   reg 			      shift_done;

   reg [10:0] 		      shift_imm_buf;			      
   
 //  parameter IDLE = 2'b00;
 //  parameter WAIT_FOR_ENCDONE = 2'b01;
 //  parameter WAIT_FOR_SEEDINIT = 2'b10;

 //  reg [1:0] 		      state;

   //assign enc_pad_out = enc_done ? enc_pad_in[127:96] :
//			shift_direction ? enc_pad_buf[127:96] : enc_pad_buf[31:0];
   
   assign enc_pad_out = shift_direction ? enc_pad_buf[127:96] : enc_pad_buf[31:0];

   //
   // FSM flow control block
   //
 /*  
   always @(posedge clk or `OR1200_RST_EVENT rst)
     if (rst == `OR1200_RST_VALUE)
       state <= IDLE;
     else begin
	case (state)
	  
	  IDLE:
	    if (shift_read & !unstall) state <= WAIT_FOR_ENCDONE;
	    else if (shift_read & unstall) state <= WAIT_FOR_SEEDINIT;
	    else state <= IDLE;
	  
	  WAIT_FOR_ENCDONE:
	    if (unstall) state <= IDLE;
	    else state <= WAIT_FOR_ENCDONE;
	  
	  WAIT_FOR_SEEDINIT:
	    if (!shift_read) state <= IDLE;
	    else state <= WAIT_FOR_SEEDINIT;
	  
	  default: state <= IDLE;
	  
        endcase
     end // else: !if(rst == `OR1200_RST_VALUE)
*/

   //
   // FSM outputs block
   //
   
   //
   // Critical: the current prototype does not allow the immediate secure load after the seed encryption
   // Example: l.seed r0,r2,0x100
   //				l.seed r31,r0,0x003
   //				l.slwz r5,4(r31)
   //	In this example, 
   //
   
   always @(posedge clk or `OR1200_RST_EVENT rst)
     if (rst == `OR1200_RST_VALUE) begin
	seed_init <= 0;
	shift_direction <= 1;
	enc_pad_buf <= 0;
	shifted_value <= 0;
	shift_imm_buf <= 0;
     end		     
     else begin	
		
	// if (new_data_seed) begin
	//    shift_direction <= 1'b1;
	//    shifted_value <= 8'b0;
	// end
	
	if (enc_done) begin
	   enc_pad_buf <= enc_pad_in;
	   if (ack_i) begin
	      shifted_value <= shifted_value + to_shift;
	      enc_pad_buf <=  shift_direction ? 
	     		      enc_pad_in << to_shift : 
	     		      enc_pad_in >> to_shift;
	      shift_done <= 1'b1;
	   end
	end
	else begin
	  
		seed_init <= 0;
		shift_done <= 1'b0;
		
		if (shift_read & !unstall)
		  shift_imm_buf <= shift_imm;

		if (shift_read & unstall) begin
		   seed_init <= 1;
		   shift_done <= 1;	     
		   shift_direction <= shift_imm[0];
		   shifted_value <= shift_imm[5:1];
		   enc_pad_buf <= shift_direction ?
				  enc_pad_in << shift_imm[5:1] :
				  enc_pad_in >> shift_imm[5:1];
		end
		
		if (ack_i) begin
		   shifted_value <= shifted_value + to_shift;
		   enc_pad_buf <=  shift_direction ? 
	     			   enc_pad_buf << to_shift : 
	     			   enc_pad_buf >> to_shift;
		   shift_done <= 1'b1;
		end
/*		
		if (shifted_value >= 8'h80) begin
		   enc_pad_buf <= enc_pad_in;
		   shifted_value <= 0;
		end  
*/
	     	    end
     end // else: !if(rst == `OR1200_RST_VALUE)
   
endmodule	  
