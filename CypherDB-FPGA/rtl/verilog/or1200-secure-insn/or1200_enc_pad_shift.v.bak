//------------------------------
// Module name: or1200_enc_pad_shift
// Function: shift the encryption pad generated by the encryption engines
// by feeding it with a seed value. The shift is controlled by:
// - explicitly by a shift instruction which states the shift initially 
//   and the direction of the shift
// - implicitly by the secure load/store instruction
// p.s. shifting instruction has to be executed initially before implicit
// shift occurs
// Creator:  Bony Chen
// Version:  1.0
// Date:     21 Jan 2015
//------------------------------

`include "or1200_defines.v"

module or1200_enc_pad_shift(
			    clk, rst,
			    // shift value and control inputs
			    shift_ra, shift_rb, shift_imm, shift_read,
			    // enc_fsm_top input
			    enc_pad_in,
			    // or_1200 lsu inputs/outputs
			    to_shift, enc_pad_out,
			    // data cache control inputs and new insn signal
			    ack_i, unstall,
			    // or1200 pipeline stall control signal
			    shift_done
			    );

   input clk;
   input rst;

   input [4:0] shift_ra;
   input [4:0] shift_rb;
   input [10:0] shift_imm;
   input shift_read;

   input [127:0] enc_pad_in;
   
   input [`shift_op_size-1:0] to_shift;
   output [31:0] enc_pad_out;

   input  ack_i;
   input  unstall;

   output shift_done;

   // internal register
   reg 	  shift_direction;
   reg [4:0] shifted_value;
   reg [127:0] enc_pad_buf;

   reg        seed_init;
   reg 	      shift_done;

   reg [10:0] shift_imm_buf;

   parameter IDLE = 2'b00;
   parameter WAIT_FOR_ENCDONE = 2'b01;
   parameter WAIT_FOR_SEEDINIT = 2'b10;

   reg [1:0]	      state;

   assign enc_pad_out = shift_direction ? enc_pad_buf[127:96] : enc_pad_buf[31:0];
   
   //
   // FSM flow control block
   //
   
   always @(posedge clk or `OR1200_RST_EVENT rst)
     if (rst == `OR1200_RST_VALUE)
	state <= IDLE;
     else begin
	case (state)
	  
	  IDLE:
	    if (shift_read & !unstall) state <= WAIT_FOR_ENCDONE;
	    else if (shift_read & unstall) state <= WAIT_FOR_SEEDINIT;
	    else state <= IDLE;
	  
	  WAIT_FOR_ENCDONE:
	    if (unstall) state <= IDLE;
	    else state <= WAIT_FOR_ENCDONE;
	  
	  WAIT_FOR_SEEDINIT:
	    if (!shift_read) state <= IDLE;
	    else state <= WAIT_FOR_SEEDINIT;
	  
	  default: state <= IDLE;
	  
        endcase
     end // else: !if(rst == `OR1200_RST_VALUE)


   //
   // FSM outputs block
   //
   
    always @(posedge clk or `OR1200_RST_EVENT rst)
     if (rst == `OR1200_RST_VALUE) begin
	seed_init <= 0;
	shift_direction <= 0;
	enc_pad_buf <= 0;
	shifted_value <= 0;
	shift_imm_buf <= 0;
     end		     
     else begin	
	case (state)
	  
	  IDLE: begin
	     seed_init <= 0;
	     shift_done <= 1'b0;

	     if (shift_read & !unstall)
	       shift_imm_buf <= shift_imm;

	     if (shift_read & unstall) begin
		seed_init <= 1;
		shift_done <= 1;	     
		shift_direction <= shift_imm[0];
		shifted_value <= shift_imm[5:1];
		enc_pad_buf <= shift_direction ?
			       enc_pad_in << shift_imm[5:1] :
			       enc_pad_in >> shift_imm[5:1];
	     end
	     
	     if (ack_i) begin
		shifted_value <= shifted_value + to_shift;
		enc_pad_buf <=  shift_direction ? 
	     			enc_pad_buf << to_shift : 
	     			enc_pad_buf >> to_shift;
		shift_done <= 1'b1;
	     end
	  end	    
	  
	  WAIT_FOR_ENCDONE: begin
	     seed_init <= 0;
	     shift_done <= 1'b0;
	     if (unstall) begin
		seed_init <= 1;
		shift_direction <= shift_imm_buf[0];
		shifted_value <= shift_imm_buf[5:1];
		enc_pad_buf <= shift_imm_buf[0] ?
			       enc_pad_in << shift_imm_buf[5:1] :
			       enc_pad_in >> shift_imm_buf[5:1];
	     end
	  end
	  
	  WAIT_FOR_SEEDINIT: begin
	     if (shift_read & unstall) begin
		seed_init <= 1;
		shift_done <= 1;	     
		shift_direction <= shift_imm[0];
		shifted_value <= shift_imm[5:1];
		enc_pad_buf <= shift_direction ?
			       enc_pad_in << shift_imm[5:1] :
			       enc_pad_in >> shift_imm[5:1];
	     end
	  end
	  
	  default: state <= IDLE;
	  
        endcase
     end // else: !if(rst == `OR1200_RST_VALUE)
   
endmodule	  